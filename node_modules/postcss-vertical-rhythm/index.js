var postcss = require('postcss');

/**
 * Convert unit to unitless px value.
 * @param  {Number} value
 * @param  {String} unit
 * @return {Number}
 */
var toPx = function (value, unit) {
  if (unit === 'em' || unit === 'rem') {
    return parseFloat(value) * 16;

  } else if (unit === '%') {
    return parseFloat(value) / 100 * 16;
  }

  // This will be a px value, thanks to strict regex.
  return value;
};

/**
 * Calculate unitless px line-height based on font-size + line-height.
 * @param  {Array} fontProps
 * @return {Number}
 */
var calcLineHeight = function (fontProps) {
  var fontSize = fontProps[1];
  var fontUnit = fontProps[2];
  var lineHeight = fontProps[3];

  return toPx(fontSize, fontUnit) * lineHeight;
};

/**
 * Gets the font declaration properties.
 * @param  {Object} decl
 * @return {Array}
 */
var getProps = function (decl) {

  // Matches {$1:font-size}{$2:unit}/{$3:line-height}.
  var fontProps = decl.value.match(/(\d+|\d+?\.\d+)(r?em|px|%)(?:\s*\/\s*)(\d+|\d+?\.\d+)\s+/);

  // Make sure the line-height value is declared.
  if (!fontProps) {
    throw decl.error('Font declaration is invalid. Make sure line-height is set.');
  }

  return fontProps;
};

/**
 * Gets the rhythm value.
 * @param  {Object} decl
 * @return {Number}
 */
var getRhythmValue = function (value, rhythmValue) {
  return rhythmValue * (parseFloat(value) || 0);
};

var UNITS_REGEX = /\b[0-9]*\.?[0-9]*bh{1}\b/;

module.exports = postcss.plugin('postcss-vertical-rhythm', function (opts) {
  opts = opts || {};
  var rootSelector = opts.rootSelector || 'body';
  var rhythmUnit = 'bh';
  var baselineHeight = opts.baselineHeight;
  var baseFontSize = opts.baseFontSize || 16;

  return function (css) {
    css.walkDecls(function transformDecl (decl) {

      // Check for root font-size.
      if (decl.parent.selector === rootSelector && !baselineHeight) {
        if (decl.prop === 'font') {
          var props = getProps(decl);

          baselineHeight = calcLineHeight(props);
        } else {
          throw decl.error('Font declaration not found in ' + rootSelector);
        }
      }

      // Calculate ryhthm value
      if (decl.value.indexOf(rhythmUnit) !== -1) {
        /*var values = decl.value.split(' ');

        for (var i = 0; i < values.length; i++) {
          if (values[i].indexOf(rhythmUnit) >= 0) {
            values[i] = getRhythmValue(values[i], baselineHeight) / baseFontSize + 'rem';
          }
        }

        decl.value = values.join(' ');*/

        decl.value = decl.value.replace(/\b[0-9]*\.?[0-9]*bh{1}\b/g, function (value) {
          return getRhythmValue(value, baselineHeight) / baseFontSize + 'rem';
        });
      }
    });
  };
});
